<!DOCTYPE html>
<html lang="ja">
<head>
    <meta name="license" content="CC BY 4.0">
    <meta name="author" content="fuhito.f (個人作成・非公式)">
    <meta name="description" content="G検定OSS実践サンプル問題 - 20問中辛分野均等の実用的な練習問題集">
    <meta name="keywords" content="G検定,AI,機械学習,OSS,実践問題,練習問題,サンプル,中辛,20問">
    <meta name="robots" content="index, follow">
    <meta property="og:title" content="G検定OSS実践サンプル問題（20問中辛）">
    <meta property="og:description" content="実際のOSSプロジェクトに基づく20問中辛分野均等の実用的なG検定練習問題集">
    <meta property="og:type" content="website">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="{{META_DESCRIPTION}}">
    <meta name="keywords" content="G検定,JDLA,ディープラーニング,OSS実践サンプル問題,AI,機械学習">
    <meta name="author" content="個人作成（非公式）">
    
    <!-- OGP Tags -->
    <meta property="og:type" content="website">
    <meta property="og:title" content="{{OG_TITLE}}">
    <meta property="og:description" content="{{OG_DESCRIPTION}}">
    <meta property="og:site_name" content="G検定 OSS実践サンプル問題（20問中辛）">
    
    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="{{TW_TITLE}}">
    <meta name="twitter:description" content="{{TW_DESCRIPTION}}">
    
    <title>G検定 OSS実践サンプル問題（20問中辛）（個人作成・非公式）</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', 'Yu Gothic', 'Hiragino Sans', sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            min-height: 100vh;
            padding: 10px;
        }
        
        .container {
            max-width: 900px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            padding: 20px;
        }
        
        .header {
            text-align: center;
            margin-bottom: 40px;
            padding-bottom: 20px;
            border-bottom: 3px solid #4a90e2;
        }
        
        .header h1 {
            font-size: 2rem;
            color: #2c3e50;
            margin-bottom: 10px;
        }
        
        .meta {
            display: flex;
            justify-content: space-around;
            margin-bottom: 15px;
            font-size: 1rem;
            color: #7f8c8d;
        }
        
        .credit-badge {
            font-size: 0.8rem;
            color: #7f8c8d;
        }
        
        .difficulty-badge {
            padding: 5px 12px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 0.9rem;
        }
        
        .difficulty-mild { background-color: #d4edda; color: #155724; }
        .difficulty-medium { background-color: #fff3cd; color: #856404; }
        .difficulty-hot { background-color: #f8d7da; color: #721c24; }
        
        /* 難易度別背景色（削除 - 問題ブロック個別に適用） */
        
        .notice {
            background: #e7f3ff;
            border-left: 4px solid #4a90e2;
            padding: 15px 20px;
            margin-bottom: 30px;
            border-radius: 4px;
            font-size: 0.9rem;
        }
        
        .question-block {
            margin-bottom: 20px;
            padding: 15px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            border-left: 4px solid #3498db;
        }
        
        /* 難易度別問題ブロック背景色 */
        .question-block.difficulty-mild { 
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); 
            border-left: 4px solid #ffc107;
        }
        .question-block.difficulty-medium { 
            background: linear-gradient(135deg, #fff3cd 0%, #ffeaa7 100%); 
            border-left: 4px solid #fd7e14;
        }
        .question-block.difficulty-hot { 
            background: linear-gradient(135deg, #f8d7da 0%, #f5c6cb 100%); 
            border-left: 4px solid #dc3545;
        }
        
        .question-number {
            font-size: 1.3rem;
            font-weight: bold;
            color: #4a90e2;
            margin-bottom: 15px;
        }
        
        .question-text {
            font-size: 1rem;
            line-height: 1.7;
            margin-bottom: 15px;
            color: #2c3e50;
            background: white;
        }
        
        .tags {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 15px;
        }
        
        .tag {
            display: inline-block;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.85em;
            font-weight: 500;
            text-decoration: none;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .tag:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        
        .choices {
            margin: 20px 0;
        }
        
        .choice {
            padding: 8px 12px;
            margin-bottom: 6px;
            background: #f8f9fa;
            border-radius: 6px;
            border-left: 3px solid #bdc3c7;
            transition: all 0.2s ease;
            cursor: pointer;
            position: relative;
            padding-left: 40px;
        }
        
        .choice::before {
            content: attr(data-answer) ".";
            position: absolute;
            left: 12px;
            top: 50%;
            transform: translateY(-50%);
            font-weight: bold;
            color: #4a90e2;
            font-size: 1rem;
            z-index: 1;
        }
        
        .choice-label {
            font-weight: bold;
            color: #4a90e2;
            margin-right: 10px;
        }
        
        /* detailsタグスタイル（JavaScript不要） */
        details {
            margin: 20px 0;
        }
        
        summary {
            background: #4a90e2;
            color: white;
            border: none;
            padding: 12px 30px;
            font-size: 1rem;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
            display: block;
            text-align: center;
            list-style: none;
            user-select: none;
        }
        
        summary::-webkit-details-marker {
            display: none;
        }
        
        summary:hover {
            background: #357abd;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(74, 144, 226, 0.3);
        }
        
        summary:focus {
            outline: 3px solid #357abd;
            outline-offset: 4px;
        }
        
        summary:focus:not(:focus-visible) {
            outline: none;
        }
        
        .answer-section {
            margin-top: 25px;
            padding: 25px;
            background: white;
            border-radius: 8px;
            border-left: 5px solid #27ae60;
            animation: slideDown 0.4s ease;
        }
        
        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .correct-answer {
            font-size: 1.2rem;
            font-weight: bold;
            color: #27ae60;
            margin-bottom: 15px;
        }
        
        .explanation {
            line-height: 1.8;
            color: #34495e;
            background: #f9f9f9;
            padding: 15px;
            border-radius: 6px;
            font-size: 0.9rem;
        }
        .explanation-divider {
            border: 0;
            height: 1px;
            background: #e0e0e0;
            margin: 16px 0;
        }
        
        .explanation-title {
            font-weight: bold;
            color: #2c3e50;
            margin-top: 10px;
            margin-bottom: 8px;
            font-size: 1.05rem;
        }
        
        
        .explanation ul {
            list-style: none;
            padding-left: 0;
            margin: 10px 0;
        }
        
        .explanation li {
            margin-bottom: 8px;
            padding-left: 0;
        }
        
        .footer {
            margin-top: 50px;
            padding-top: 30px;
            border-top: 2px solid #e0e0e0;
            text-align: center;
            color: #7f8c8d;
            font-size: 0.9rem;
        }
        
        /* スマホ最適化 */
        @media (max-width: 768px) {
            body {
                padding: 5px;
            }
            
            .container {
                padding: 10px;
                margin: 5px;
                border-radius: 8px;
            }
            
            .header h1 {
                font-size: 1.3rem;
            }
            
            .question-block {
                padding: 10px;
                margin-bottom: 10px;
            }
            
            .question-text {
                font-size: 0.9rem;
                line-height: 1.5;
            }
            
            .choice {
                padding: 5px 8px;
                margin-bottom: 3px;
                font-size: 0.85rem;
                padding-left: 35px;
            }
            
            .choice::before {
                left: 8px;
                font-size: 0.9rem;
            }
            
            .explanation {
                font-size: 0.9rem;
                padding: 10px;
            }
            
            summary {
                padding: 6px 10px;
                font-size: 0.85rem;
            }
            
            /* スマホでは印刷ボタンを非表示 */
            .print-button {
                display: none;
            }
        }
        
        /* 印刷用スタイル */
        @media print {
            body {
                background: white;
                padding: 0;
            }
            
            .container {
                box-shadow: none;
                max-width: 100%;
                padding: 20px;
            }
            
            .question-block {
                page-break-inside: avoid;
                margin-bottom: 30px;
                border: 1px solid #ccc;
                background: white !important;
            }
            
            .question-text,
            .choice {
                background: white !important;
            }
            
            /* 解答ボタンを非表示 */
            summary {
                display: none;
            }
            
            /* 解答を常に表示 */
            details {
                display: block;
            }
            
            details[open] .answer-section,
            details .answer-section {
                display: block;
                page-break-before: avoid;
                background: white !important;
                animation: none;
            }
            
            .explanation {
                background: white !important;
            }
            
            /* 印刷ボタンを非表示 */
            .print-button {
                display: none;
            }
        }
        
        /* 印刷ボタン */
        .print-button {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: #4a90e2;
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 50px;
            cursor: pointer;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(74, 144, 226, 0.4);
            z-index: 1000;
            transition: all 0.3s ease;
            font-size: 1rem;
        }
        
        .print-button:hover {
            background: #357abd;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(74, 144, 226, 0.5);
        }
        
        .print-button:focus {
            outline: 3px solid #357abd;
            outline-offset: 3px;
        }
    </style>
</head>
<body>
    <main>
        <div class="container">
            <header class="header">
                <h1>G検定 OSS実践サンプル問題（20問中辛）</h1>
                <div class="meta">
                    <div class="difficulty-badge difficulty-medium">難易度: 中辛</div>
                    <div>OSS実践サンプル | 全20問</div>
                    <div class="credit-badge">by fuhito.f (非公式)</div>
                </div>
            </header>
            
            <div class="notice" role="alert">
                <strong>⚠️ 重要な注意事項</strong><br>
                本問題は個人が作成した非公式のOSS実践サンプル問題です。<strong>日本ディープラーニング協会（JDLA）とは一切関係ありません。</strong><br>
                実際のG検定試験問題とは異なります。本コンテンツはAIにより自動生成されており、内容の正確性を保証するものではありません。<br>
                必ず公式教材と併用してください。本問題の使用により生じたいかなる損害についても責任を負いません。
            </div>
            
            <!-- 問題ブロック（動的に生成） -->
            <div class="question-block difficulty-medium">
    <div class="question-number">問題 1</div>
    <div class="question-text">scikit-learnのGridSearchCVで交差検証を行う際、データの分割方法として適切なのはどれか。</div>
    <div class="tags">
      <span class="tag">#scikit-learn</span>
      <span class="tag">#時系列データ</span>
      <span class="tag">#交差検証</span>
      <span class="tag">#データ分割</span>
      <span class="tag">#評価設計</span>
    </div>
    <div class="choices">
  <div class="choice" data-answer="A">訓練データとテストデータをランダムに分割する</div>
  <div class="choice" data-answer="B">時系列データの場合は時間順序を保持して分割する</div>
  <div class="choice" data-answer="C">すべてのデータを訓練に使用し、外部データでテストする</div>
  <div class="choice" data-answer="D">データの前処理前に分割を行う</div>
    </div>
    <details>
        <summary>解答を見る</summary>
        <div class="answer-section">
            <div class="correct-answer">正解: B</div>
            <div class="explanation">
                <div class="explanation-title">正解解説</div>
                <p>時系列データでは、未来のデータが過去のデータに基づいて予測されるため、時間順序を保持した分割（時間的順序での分割）が必要です。ランダム分割では、未来の情報が過去の学習に漏洩し、過度に楽観的な評価になってしまいます。</p>
                
                <hr class="explanation-divider">
                
                <div class="explanation-title">誤答解説</div>
                <ul>
      <li><strong>選択肢A:</strong> 時系列データでは時間漏洩が発生する→決定打</li>
      <li><strong>選択肢B:</strong> 全データを訓練に使うと過学習のリスクが高い→致命的</li>
      <li><strong>選択肢C:</strong> 前処理後に分割するとデータリークが発生する→本質的誤り</li>
                </ul>
            </div>
        </div>
    </details>
</div>

<div class="question-block difficulty-medium">
    <div class="question-number">問題 2</div>
    <div class="question-text">PyTorchで勾配消失問題を防ぐための手法として正しいのはどれか。</div>
    <div class="tags">
      <span class="tag">#PyTorch</span>
      <span class="tag">#勾配消失</span>
      <span class="tag">#ReLU</span>
      <span class="tag">#重み初期化</span>
      <span class="tag">#深層学習</span>
    </div>
    <div class="choices">
  <div class="choice" data-answer="A">学習率を大きく設定する</div>
  <div class="choice" data-answer="B">ReLU活性化関数を使用し、適切な重み初期化を行う</div>
  <div class="choice" data-answer="C">バッチサイズを小さく設定する</div>
  <div class="choice" data-answer="D">エポック数を増やす</div>
    </div>
    <details>
        <summary>解答を見る</summary>
        <div class="answer-section">
            <div class="correct-answer">正解: B</div>
            <div class="explanation">
                <div class="explanation-title">正解解説</div>
                <p>勾配消失問題を防ぐには、ReLU活性化関数（勾配が0または1）を使用し、Xavier初期化やHe初期化などの適切な重み初期化を行うことが重要です。これにより、勾配が層を伝播する際に適切に保持されます。</p>
                
                <hr class="explanation-divider">
                
                <div class="explanation-title">誤答解説</div>
                <ul>
      <li><strong>選択肢A:</strong> 学習率を大きくすると発散のリスクが高い→決定打</li>
      <li><strong>選択肢B:</strong> バッチサイズは勾配消失と直接関係ない→致命的</li>
      <li><strong>選択肢C:</strong> エポック数は収束に関係するが勾配消失とは別問題→本質的誤り</li>
                </ul>
            </div>
        </div>
    </details>
</div>

<div class="question-block difficulty-medium">
    <div class="question-number">問題 3</div>
    <div class="question-text">MLflowでモデルバージョニングを行う際、モデルの登録に必要な情報はどれか。</div>
    <div class="tags">
      <span class="tag">#MLflow</span>
      <span class="tag">#モデルバージョニング</span>
      <span class="tag">#メタデータ</span>
      <span class="tag">#再現性</span>
      <span class="tag">#デプロイ</span>
    </div>
    <div class="choices">
  <div class="choice" data-answer="A">モデルファイルのパスのみ</div>
  <div class="choice" data-answer="B">モデルファイル、メタデータ、実行環境情報</div>
  <div class="choice" data-answer="C">モデルの精度のみ</div>
  <div class="choice" data-answer="D">学習に使用したデータセットのみ</div>
    </div>
    <details>
        <summary>解答を見る</summary>
        <div class="answer-section">
            <div class="correct-answer">正解: B</div>
            <div class="explanation">
                <div class="explanation-title">正解解説</div>
                <p>MLflowでモデルを登録する際は、モデルファイル、メタデータ（パラメータ、メトリクス）、実行環境情報（Pythonバージョン、依存関係）を含める必要があります。これにより、モデルの再現性とデプロイ時の環境整合性を確保できます。</p>
                
                <hr class="explanation-divider">
                
                <div class="explanation-title">誤答解説</div>
                <ul>
      <li><strong>選択肢A:</strong> パスのみでは再現性が確保できない→決定打</li>
      <li><strong>選択肢B:</strong> 精度のみではモデルの詳細が不明→致命的</li>
      <li><strong>選択肢C:</strong> データセットのみではモデル自体が不明→本質的誤り</li>
                </ul>
            </div>
        </div>
    </details>
</div>

<div class="question-block difficulty-medium">
    <div class="question-number">問題 4</div>
    <div class="question-text">TensorRTでINT8量子化を行う際の制約はどれか。</div>
    <div class="tags">
      <span class="tag">#TensorRT</span>
      <span class="tag">#INT8量子化</span>
      <span class="tag">#キャリブレーション</span>
      <span class="tag">#最適化</span>
      <span class="tag">#推論</span>
    </div>
    <div class="choices">
  <div class="choice" data-answer="A">すべてのレイヤーがINT8に対応している</div>
  <div class="choice" data-answer="B">動的レンジのキャリブレーションが必要</div>
  <div class="choice" data-answer="C">FP32精度と完全に同じ結果が得られる</div>
  <div class="choice" data-answer="D">バッチサイズは1のみサポート</div>
    </div>
    <details>
        <summary>解答を見る</summary>
        <div class="answer-section">
            <div class="correct-answer">正解: B</div>
            <div class="explanation">
                <div class="explanation-title">正解解説</div>
                <p>TensorRTのINT8量子化では、動的レンジのキャリブレーションが必要です。代表的なデータセットを使用して各レイヤーの活性化値の分布を分析し、適切な量子化パラメータを決定する必要があります。</p>
                
                <hr class="explanation-divider">
                
                <div class="explanation-title">誤答解説</div>
                <ul>
      <li><strong>選択肢A:</strong> 一部レイヤーはINT8非対応→決定打</li>
      <li><strong>選択肢B:</strong> 量子化により若干の精度劣化は避けられない→致命的</li>
      <li><strong>選択肢C:</strong> バッチサイズは複数サポート→本質的誤り</li>
                </ul>
            </div>
        </div>
    </details>
</div>

<div class="question-block difficulty-medium">
    <div class="question-number">問題 5</div>
    <div class="question-text">pandasでカテゴリ変数をエンコーディングする際、データリークを防ぐ正しい方法はどれか。</div>
    <div class="tags">
      <span class="tag">#pandas</span>
      <span class="tag">#カテゴリ変数</span>
      <span class="tag">#エンコーディング</span>
      <span class="tag">#データリーク</span>
      <span class="tag">#前処理</span>
    </div>
    <div class="choices">
  <div class="choice" data-answer="A">全データセットでラベルエンコーディングを適用する</div>
  <div class="choice" data-answer="B">訓練データでfitし、テストデータにtransformを適用する</div>
  <div class="choice" data-answer="C">各カテゴリにランダムな数値を割り当てる</div>
  <div class="choice" data-answer="D">テストデータの情報も含めてエンコーディングする</div>
    </div>
    <details>
        <summary>解答を見る</summary>
        <div class="answer-section">
            <div class="correct-answer">正解: B</div>
            <div class="explanation">
                <div class="explanation-title">正解解説</div>
                <p>カテゴリ変数のエンコーディングでは、訓練データのみでエンコーダーをfitし、そのエンコーダーを使ってテストデータにtransformを適用する必要があります。テストデータの情報を含めてエンコーディングすると、データリークが発生します。</p>
                
                <hr class="explanation-divider">
                
                <div class="explanation-title">誤答解説</div>
                <ul>
      <li><strong>選択肢A:</strong> 全データセットでエンコーディングするとデータリークが発生→決定打</li>
      <li><strong>選択肢B:</strong> ランダムな数値では意味のある情報が失われる→致命的</li>
      <li><strong>選択肢C:</strong> テストデータの情報を含めると過度に楽観的な評価になる→本質的誤り</li>
                </ul>
            </div>
        </div>
    </details>
</div>

<div class="question-block difficulty-medium">
    <div class="question-number">問題 6</div>
    <div class="question-text">matplotlibで複数のサブプロットを作成する際、メモリ効率を考慮した正しい方法はどれか。</div>
    <div class="tags">
      <span class="tag">#matplotlib</span>
      <span class="tag">#サブプロット</span>
      <span class="tag">#メモリ効率</span>
      <span class="tag">#Figure</span>
      <span class="tag">#可視化</span>
    </div>
    <div class="choices">
  <div class="choice" data-answer="A">すべてのサブプロットを一つのFigureに描画する</div>
  <div class="choice" data-answer="B">各サブプロットごとに新しいFigureを作成する</div>
  <div class="choice" data-answer="C">plt.subplots()を使用し、不要なAxesは削除する</div>
  <div class="choice" data-answer="D">すべてのプロットをメモリに保持する</div>
    </div>
    <details>
        <summary>解答を見る</summary>
        <div class="answer-section">
            <div class="correct-answer">正解: C</div>
            <div class="explanation">
                <div class="explanation-title">正解解説</div>
                <p>matplotlibでメモリ効率を考慮する場合、plt.subplots()で必要な数のサブプロットを作成し、使用しないAxesは削除（remove()）するのが適切です。これにより、メモリ使用量を最小限に抑えながら効率的にプロットできます。</p>
                
                <hr class="explanation-divider">
                
                <div class="explanation-title">誤答解説</div>
                <ul>
      <li><strong>選択肢A:</strong> 一つのFigureに描画しすぎるとメモリを大量消費→決定打</li>
      <li><strong>選択肢B:</strong> 各サブプロットごとにFigureを作成すると非効率→致命的</li>
      <li><strong>選択肢C:</strong> すべてをメモリに保持するとメモリ不足の原因→本質的誤り</li>
                </ul>
            </div>
        </div>
    </details>
</div>

<div class="question-block difficulty-medium">
    <div class="question-number">問題 7</div>
    <div class="question-text">Hugging Face TransformersでBERTモデルを使用する際、最大トークン長の制限について正しいのはどれか。</div>
    <div class="tags">
      <span class="tag">#Transformers</span>
      <span class="tag">#BERT</span>
      <span class="tag">#トークン長</span>
      <span class="tag">#制限</span>
      <span class="tag">#NLP</span>
    </div>
    <div class="choices">
  <div class="choice" data-answer="A">最大トークン長に制限はない</div>
  <div class="choice" data-answer="B">最大512トークンまで処理可能</div>
  <div class="choice" data-answer="C">最大1024トークンまで処理可能</div>
  <div class="choice" data-answer="D">モデルによって最大トークン長が異なる</div>
    </div>
    <details>
        <summary>解答を見る</summary>
        <div class="answer-section">
            <div class="correct-answer">正解: D</div>
            <div class="explanation">
                <div class="explanation-title">正解解説</div>
                <p>Hugging Face TransformersのBERTモデルでは、モデルによって最大トークン長が異なります。BERT-baseは512トークン、BERT-largeは512トークン、Longformerは4096トークンなど、モデルアーキテクチャに応じて制限が設定されています。</p>
                
                <hr class="explanation-divider">
                
                <div class="explanation-title">誤答解説</div>
                <ul>
      <li><strong>選択肢A:</strong> トークン長には必ず制限がある→決定打</li>
      <li><strong>選択肢B:</strong> すべてのBERTモデルが512トークンではない→致命的</li>
      <li><strong>選択肢C:</strong> モデルによって制限が異なる→本質的誤り</li>
                </ul>
            </div>
        </div>
    </details>
</div>

<div class="question-block difficulty-medium">
    <div class="question-number">問題 8</div>
    <div class="question-text">OpenCVで画像の幾何変換を行う際、アフィン変換と射影変換の違いはどれか。</div>
    <div class="tags">
      <span class="tag">#OpenCV</span>
      <span class="tag">#幾何変換</span>
      <span class="tag">#アフィン変換</span>
      <span class="tag">#射影変換</span>
      <span class="tag">#画像処理</span>
    </div>
    <div class="choices">
  <div class="choice" data-answer="A">アフィン変換は平行線を保持し、射影変換は保持しない</div>
  <div class="choice" data-answer="B">射影変換は平行線を保持し、アフィン変換は保持しない</div>
  <div class="choice" data-answer="C">両方とも平行線を保持する</div>
  <div class="choice" data-answer="D">両方とも平行線を保持しない</div>
    </div>
    <details>
        <summary>解答を見る</summary>
        <div class="answer-section">
            <div class="correct-answer">正解: A</div>
            <div class="explanation">
                <div class="explanation-title">正解解説</div>
                <p>アフィン変換は平行線を保持し、長さ比や角度比も保持します。一方、射影変換（ホモグラフィ）は平行線を保持せず、遠近感による変形を表現できます。アフィン変換は射影変換の特殊な場合です。</p>
                
                <hr class="explanation-divider">
                
                <div class="explanation-title">誤答解説</div>
                <ul>
      <li><strong>選択肢A:</strong> 射影変換は平行線を保持しない→決定打</li>
      <li><strong>選択肢B:</strong> アフィン変換は平行線を保持する→致命的</li>
      <li><strong>選択肢C:</strong> 両方とも平行線を保持するわけではない→本質的誤り</li>
                </ul>
            </div>
        </div>
    </details>
</div>

<div class="question-block difficulty-medium">
    <div class="question-number">問題 9</div>
    <div class="question-text">Horovodで分散学習を行う際、勾配の同期方法はどれか。</div>
    <div class="tags">
      <span class="tag">#Horovod</span>
      <span class="tag">#分散学習</span>
      <span class="tag">#AllReduce</span>
      <span class="tag">#勾配同期</span>
      <span class="tag">#並列処理</span>
    </div>
    <div class="choices">
  <div class="choice" data-answer="A">各ワーカーが独立して勾配を計算する</div>
  <div class="choice" data-answer="B">AllReduce操作で勾配を平均化する</div>
  <div class="choice" data-answer="C">マスター・ワーカー方式で勾配を集約する</div>
  <div class="choice" data-answer="D">勾配の同期は不要である</div>
    </div>
    <details>
        <summary>解答を見る</summary>
        <div class="answer-section">
            <div class="correct-answer">正解: B</div>
            <div class="explanation">
                <div class="explanation-title">正解解説</div>
                <p>Horovodでは、各ワーカーが計算した勾配をAllReduce操作で平均化し、同期します。これにより、全ワーカーの勾配を統合し、一貫したモデル更新を実現します。AllReduceは効率的な分散通信アルゴリズムです。</p>
                
                <hr class="explanation-divider">
                
                <div class="explanation-title">誤答解説</div>
                <ul>
      <li><strong>選択肢A:</strong> 独立計算では分散学習にならない→決定打</li>
      <li><strong>選択肢B:</strong> マスター・ワーカー方式は非効率→致命的</li>
      <li><strong>選択肢C:</strong> 勾配同期は分散学習の核心→本質的誤り</li>
                </ul>
            </div>
        </div>
    </details>
</div>

<div class="question-block difficulty-medium">
    <div class="question-number">問題 10</div>
    <div class="question-text">SHAPでモデルの説明可能性を分析する際、TreeExplainerの適用条件はどれか。</div>
    <div class="tags">
      <span class="tag">#SHAP</span>
      <span class="tag">#TreeExplainer</span>
      <span class="tag">#ツリーベース</span>
      <span class="tag">#説明可能性</span>
      <span class="tag">#モデル解釈</span>
    </div>
    <div class="choices">
  <div class="choice" data-answer="A">すべての機械学習モデルに適用可能</div>
  <div class="choice" data-answer="B">ツリーベースのモデル（Random Forest、XGBoost等）にのみ適用可能</div>
  <div class="choice" data-answer="C">深層学習モデルのみに適用可能</div>
  <div class="choice" data-answer="D">線形モデルのみに適用可能</div>
    </div>
    <details>
        <summary>解答を見る</summary>
        <div class="answer-section">
            <div class="correct-answer">正解: B</div>
            <div class="explanation">
                <div class="explanation-title">正解解説</div>
                <p>SHAPのTreeExplainerは、ツリーベースのモデル（Random Forest、XGBoost、LightGBM、CatBoost等）にのみ適用可能です。これらのモデルでは、ツリー構造を利用して効率的にSHAP値を計算できます。</p>
                
                <hr class="explanation-divider">
                
                <div class="explanation-title">誤答解説</div>
                <ul>
      <li><strong>選択肢A:</strong> すべてのモデルに適用できるわけではない→決定打</li>
      <li><strong>選択肢B:</strong> 深層学習モデルには別のExplainerが必要→致命的</li>
      <li><strong>選択肢C:</strong> 線形モデルにはLinearExplainerを使用→本質的誤り</li>
                </ul>
            </div>
        </div>
    </details>
</div>

<div class="question-block difficulty-medium">
    <div class="question-number">問題 11</div>
    <div class="question-text">Weights & Biasesで実験を追跡する際、wandb.log()の正しい使用方法はどれか。</div>
    <div class="tags">
      <span class="tag">#Weights & Biases</span>
      <span class="tag">#wandb.log</span>
      <span class="tag">#実験追跡</span>
      <span class="tag">#メトリクス</span>
      <span class="tag">#可視化</span>
    </div>
    <div class="choices">
  <div class="choice" data-answer="A">実験開始時に一度だけ呼び出す</div>
  <div class="choice" data-answer="B">各エポックまたはバッチごとに呼び出してメトリクスを記録する</div>
  <div class="choice" data-answer="C">実験終了時に一度だけ呼び出す</div>
  <div class="choice" data-answer="D">エラーが発生した時のみ呼び出す</div>
    </div>
    <details>
        <summary>解答を見る</summary>
        <div class="answer-section">
            <div class="correct-answer">正解: B</div>
            <div class="explanation">
                <div class="explanation-title">正解解説</div>
                <p>wandb.log()は、各エポックやバッチごとに呼び出してメトリクス（損失、精度等）を記録するために使用します。これにより、学習過程の詳細な追跡と可視化が可能になります。</p>
                
                <hr class="explanation-divider">
                
                <div class="explanation-title">誤答解説</div>
                <ul>
      <li><strong>選択肢A:</strong> 一度だけでは学習過程が追跡できない→決定打</li>
      <li><strong>選択肢B:</strong> 終了時のみでは詳細な分析ができない→致命的</li>
      <li><strong>選択肢C:</strong> エラー時のみでは実験追跡にならない→本質的誤り</li>
                </ul>
            </div>
        </div>
    </details>
</div>

<div class="question-block difficulty-medium">
    <div class="question-number">問題 12</div>
    <div class="question-text">XGBoostで過学習を防ぐためのパラメータ設定として適切なのはどれか。</div>
    <div class="tags">
      <span class="tag">#XGBoost</span>
      <span class="tag">#過学習</span>
      <span class="tag">#learning_rate</span>
      <span class="tag">#early_stopping</span>
      <span class="tag">#正則化</span>
    </div>
    <div class="choices">
  <div class="choice" data-answer="A">learning_rateを大きくし、n_estimatorsを増やす</div>
  <div class="choice" data-answer="B">learning_rateを小さくし、early_stoppingを使用する</div>
  <div class="choice" data-answer="C">max_depthを大きくし、min_child_weightを小さくする</div>
  <div class="choice" data-answer="D">subsampleを1.0に設定し、colsample_bytreeを1.0にする</div>
    </div>
    <details>
        <summary>解答を見る</summary>
        <div class="answer-section">
            <div class="correct-answer">正解: B</div>
            <div class="explanation">
                <div class="explanation-title">正解解説</div>
                <p>XGBoostで過学習を防ぐには、learning_rateを小さくし（例：0.01-0.1）、early_stoppingを使用して最適なn_estimatorsを決定します。これにより、モデルの複雑さを適切に制御し、過学習を防げます。</p>
                
                <hr class="explanation-divider">
                
                <div class="explanation-title">誤答解説</div>
                <ul>
      <li><strong>選択肢A:</strong> learning_rateを大きくすると過学習のリスクが高い→決定打</li>
      <li><strong>選択肢B:</strong> max_depthを大きくするとモデルが複雑になりすぎる→致命的</li>
      <li><strong>選択肢C:</strong> subsample=1.0では正則化効果がない→本質的誤り</li>
                </ul>
            </div>
        </div>
    </details>
</div>

<div class="question-block difficulty-medium">
    <div class="question-number">問題 13</div>
    <div class="question-text">Kubeflow Pipelinesでパイプラインを実行する際、コンポーネント間のデータ受け渡し方法はどれか。</div>
    <div class="tags">
      <span class="tag">#Kubeflow</span>
      <span class="tag">#Pipelines</span>
      <span class="tag">#Artifact Store</span>
      <span class="tag">#データ受け渡し</span>
      <span class="tag">#MLOps</span>
    </div>
    <div class="choices">
  <div class="choice" data-answer="A">ファイルシステムを直接共有する</div>
  <div class="choice" data-answer="B">KubernetesのVolumeを使用する</div>
  <div class="choice" data-answer="C">コンポーネント間で直接メモリを共有する</div>
  <div class="choice" data-answer="D">KubeflowのArtifact Storeを使用する</div>
    </div>
    <details>
        <summary>解答を見る</summary>
        <div class="answer-section">
            <div class="correct-answer">正解: D</div>
            <div class="explanation">
                <div class="explanation-title">正解解説</div>
                <p>Kubeflow Pipelinesでは、コンポーネント間のデータ受け渡しにArtifact Storeを使用します。これにより、データのバージョン管理、メタデータの追跡、再利用性を確保できます。</p>
                
                <hr class="explanation-divider">
                
                <div class="explanation-title">誤答解説</div>
                <ul>
      <li><strong>選択肢A:</strong> ファイルシステム直接共有は非推奨→決定打</li>
      <li><strong>選択肢B:</strong> Kubernetes Volumeは低レベルすぎる→致命的</li>
      <li><strong>選択肢C:</strong> メモリ直接共有はスケーラビリティに問題→本質的誤り</li>
                </ul>
            </div>
        </div>
    </details>
</div>

<div class="question-block difficulty-medium">
    <div class="question-number">問題 14</div>
    <div class="question-text">ONNXモデルを異なるフレームワーク間で変換する際の制約はどれか。</div>
    <div class="tags">
      <span class="tag">#ONNX</span>
      <span class="tag">#モデル変換</span>
      <span class="tag">#演算子サポート</span>
      <span class="tag">#互換性</span>
      <span class="tag">#推論</span>
    </div>
    <div class="choices">
  <div class="choice" data-answer="A">すべての演算子が変換可能</div>
  <div class="choice" data-answer="B">ONNXでサポートされていない演算子は変換できない</div>
  <div class="choice" data-answer="C">モデルの精度は必ず保持される</div>
  <div class="choice" data-answer="D">変換は常に成功する</div>
    </div>
    <details>
        <summary>解答を見る</summary>
        <div class="answer-section">
            <div class="correct-answer">正解: B</div>
            <div class="explanation">
                <div class="explanation-title">正解解説</div>
                <p>ONNXモデルの変換では、ONNXでサポートされていない演算子（カスタム演算子など）は変換できません。変換前に、使用している演算子がONNXでサポートされているかを確認する必要があります。</p>
                
                <hr class="explanation-divider">
                
                <div class="explanation-title">誤答解説</div>
                <ul>
      <li><strong>選択肢A:</strong> すべての演算子が変換できるわけではない→決定打</li>
      <li><strong>選択肢B:</strong> 精度は変換過程で若干変動する可能性がある→致命的</li>
      <li><strong>選択肢C:</strong> 変換は失敗する場合もある→本質的誤り</li>
                </ul>
            </div>
        </div>
    </details>
</div>

<div class="question-block difficulty-medium">
    <div class="question-number">問題 15</div>
    <div class="question-text">Apache Sparkで大容量データを処理する際、パーティション数の決定要因はどれか。</div>
    <div class="tags">
      <span class="tag">#Apache Spark</span>
      <span class="tag">#パーティション</span>
      <span class="tag">#CPUコア数</span>
      <span class="tag">#データサイズ</span>
      <span class="tag">#並列処理</span>
    </div>
    <div class="choices">
  <div class="choice" data-answer="A">データサイズのみ</div>
  <div class="choice" data-answer="B">クラスターのCPUコア数とデータサイズ</div>
  <div class="choice" data-answer="C">メモリサイズのみ</div>
  <div class="choice" data-answer="D">ネットワーク帯域のみ</div>
    </div>
    <details>
        <summary>解答を見る</summary>
        <div class="answer-section">
            <div class="correct-answer">正解: B</div>
            <div class="explanation">
                <div class="explanation-title">正解解説</div>
                <p>Sparkのパーティション数は、クラスターのCPUコア数とデータサイズを考慮して決定します。一般的に、CPUコア数の2-4倍程度が推奨されますが、データサイズが小さい場合は過度なパーティションは非効率です。</p>
                
                <hr class="explanation-divider">
                
                <div class="explanation-title">誤答解説</div>
                <ul>
      <li><strong>選択肢A:</strong> データサイズのみでは最適化できない→決定打</li>
      <li><strong>選択肢B:</strong> メモリサイズのみでは並列性が考慮されない→致命的</li>
      <li><strong>選択肢C:</strong> ネットワーク帯域のみではCPUリソースが無駄→本質的誤り</li>
                </ul>
            </div>
        </div>
    </details>
</div>

<div class="question-block difficulty-medium">
    <div class="question-number">問題 16</div>
    <div class="question-text">Plotlyでインタラクティブな可視化を作成する際、パフォーマンスを向上させる方法はどれか。</div>
    <div class="tags">
      <span class="tag">#Plotly</span>
      <span class="tag">#インタラクティブ</span>
      <span class="tag">#パフォーマンス</span>
      <span class="tag">#データサンプリング</span>
      <span class="tag">#可視化</span>
    </div>
    <div class="choices">
  <div class="choice" data-answer="A">すべてのデータポイントを一度に描画する</div>
  <div class="choice" data-answer="B">データサンプリングや集約を行い、表示するデータ量を制限する</div>
  <div class="choice" data-answer="C">すべてのアニメーションを同時に実行する</div>
  <div class="choice" data-answer="D">高解像度の画像を大量に使用する</div>
    </div>
    <details>
        <summary>解答を見る</summary>
        <div class="answer-section">
            <div class="correct-answer">正解: B</div>
            <div class="explanation">
                <div class="explanation-title">正解解説</div>
                <p>Plotlyでパフォーマンスを向上させるには、データサンプリングや集約を行い、表示するデータ量を適切に制限することが重要です。大量のデータポイントを一度に描画すると、ブラウザの応答が遅くなります。</p>
                
                <hr class="explanation-divider">
                
                <div class="explanation-title">誤答解説</div>
                <ul>
      <li><strong>選択肢A:</strong> 全データポイントの同時描画は非効率→決定打</li>
      <li><strong>選択肢B:</strong> 同時アニメーション実行はパフォーマンスを悪化→致命的</li>
      <li><strong>選択肢C:</strong> 高解像度画像大量使用はメモリを消費→本質的誤り</li>
                </ul>
            </div>
        </div>
    </details>
</div>

<div class="question-block difficulty-medium">
    <div class="question-number">問題 17</div>
    <div class="question-text">spaCyで固有表現認識（NER）を行う際、モデルの選択基準はどれか。</div>
    <div class="tags">
      <span class="tag">#spaCy</span>
      <span class="tag">#NER</span>
      <span class="tag">#固有表現認識</span>
      <span class="tag">#モデル選択</span>
      <span class="tag">#言語処理</span>
    </div>
    <div class="choices">
  <div class="choice" data-answer="A">すべての言語で同じモデルを使用する</div>
  <div class="choice" data-answer="B">対象言語とタスクに応じて適切なモデルを選択する</div>
  <div class="choice" data-answer="C">モデルサイズが大きいほど精度が高い</div>
  <div class="choice" data-answer="D">最新のモデルを常に使用する</div>
    </div>
    <details>
        <summary>解答を見る</summary>
        <div class="answer-section">
            <div class="correct-answer">正解: B</div>
            <div class="explanation">
                <div class="explanation-title">正解解説</div>
                <p>spaCyのNERでは、対象言語（英語、日本語等）とタスク（一般、医療、法律等）に応じて適切なモデルを選択する必要があります。各モデルは特定のドメインに最適化されています。</p>
                
                <hr class="explanation-divider">
                
                <div class="explanation-title">誤答解説</div>
                <ul>
      <li><strong>選択肢A:</strong> 言語によってモデルが異なる→決定打</li>
      <li><strong>選択肢B:</strong> モデルサイズと精度は必ずしも比例しない→致命的</li>
      <li><strong>選択肢C:</strong> 最新モデルが常に最適とは限らない→本質的誤り</li>
                </ul>
            </div>
        </div>
    </details>
</div>

<div class="question-block difficulty-medium">
    <div class="question-number">問題 18</div>
    <div class="question-text">Pillowで画像のリサイズを行う際、アスペクト比を保持する正しい方法はどれか。</div>
    <div class="tags">
      <span class="tag">#Pillow</span>
      <span class="tag">#画像リサイズ</span>
      <span class="tag">#アスペクト比</span>
      <span class="tag">#thumbnail</span>
      <span class="tag">#画像処理</span>
    </div>
    <div class="choices">
  <div class="choice" data-answer="A">resize()メソッドで直接サイズを指定する</div>
  <div class="choice" data-answer="B">thumbnail()メソッドを使用する</div>
  <div class="choice" data-answer="C">crop()メソッドで切り取る</div>
  <div class="choice" data-answer="D">rotate()メソッドで回転させる</div>
    </div>
    <details>
        <summary>解答を見る</summary>
        <div class="answer-section">
            <div class="correct-answer">正解: B</div>
            <div class="explanation">
                <div class="explanation-title">正解解説</div>
                <p>Pillowでアスペクト比を保持してリサイズするには、thumbnail()メソッドを使用します。このメソッドは、指定したサイズ内に収まるようにアスペクト比を保持してリサイズします。</p>
                
                <hr class="explanation-divider">
                
                <div class="explanation-title">誤答解説</div>
                <ul>
      <li><strong>選択肢A:</strong> resize()はアスペクト比を保持しない→決定打</li>
      <li><strong>選択肢B:</strong> crop()は切り取りでリサイズではない→致命的</li>
      <li><strong>選択肢C:</strong> rotate()は回転でリサイズではない→本質的誤り</li>
                </ul>
            </div>
        </div>
    </details>
</div>

<div class="question-block difficulty-medium">
    <div class="question-number">問題 19</div>
    <div class="question-text">Rayで分散処理を行う際、@ray.remoteデコレータの役割はどれか。</div>
    <div class="tags">
      <span class="tag">#Ray</span>
      <span class="tag">#分散処理</span>
      <span class="tag">#@ray.remote</span>
      <span class="tag">#リモート実行</span>
      <span class="tag">#並列処理</span>
    </div>
    <div class="choices">
  <div class="choice" data-answer="A">関数の実行時間を測定する</div>
  <div class="choice" data-answer="B">関数をリモート実行可能にする</div>
  <div class="choice" data-answer="C">関数のメモリ使用量を監視する</div>
  <div class="choice" data-answer="D">関数のエラーハンドリングを行う</div>
    </div>
    <details>
        <summary>解答を見る</summary>
        <div class="answer-section">
            <div class="correct-answer">正解: B</div>
            <div class="explanation">
                <div class="explanation-title">正解解説</div>
                <p>Rayの@ray.remoteデコレータは、通常のPython関数をリモート実行可能なタスクに変換します。これにより、関数をクラスター内の任意のノードで並列実行できます。</p>
                
                <hr class="explanation-divider">
                
                <div class="explanation-title">誤答解説</div>
                <ul>
      <li><strong>選択肢A:</strong> 実行時間測定は別の機能→決定打</li>
      <li><strong>選択肢B:</strong> メモリ監視は別の機能→致命的</li>
      <li><strong>選択肢C:</strong> エラーハンドリングは別途実装が必要→本質的誤り</li>
                </ul>
            </div>
        </div>
    </details>
</div>

<div class="question-block difficulty-medium">
    <div class="question-number">問題 20</div>
    <div class="question-text">LIMEでモデルの局所的な説明を生成する際の制約はどれか。</div>
    <div class="tags">
      <span class="tag">#LIME</span>
      <span class="tag">#局所的説明</span>
      <span class="tag">#安定性</span>
      <span class="tag">#線形近似</span>
      <span class="tag">#モデル解釈</span>
    </div>
    <div class="choices">
  <div class="choice" data-answer="A">すべてのモデルで同じ精度の説明が得られる</div>
  <div class="choice" data-answer="B">説明の安定性に課題があり、同じ入力でも結果が変動する可能性がある</div>
  <div class="choice" data-answer="C">大規模データセットでは必ず高速に実行される</div>
  <div class="choice" data-answer="D">説明結果は常に人間が理解しやすい</div>
    </div>
    <details>
        <summary>解答を見る</summary>
        <div class="answer-section">
            <div class="correct-answer">正解: B</div>
            <div class="explanation">
                <div class="explanation-title">正解解説</div>
                <p>LIMEは局所的な線形近似に基づくため、説明の安定性に課題があります。同じ入力でも、サンプリングのランダム性により結果が変動する可能性があり、複数回実行して平均を取ることが推奨されます。</p>
                
                <hr class="explanation-divider">
                
                <div class="explanation-title">誤答解説</div>
                <ul>
      <li><strong>選択肢A:</strong> モデルによって説明精度は異なる→決定打</li>
      <li><strong>選択肢B:</strong> 大規模データでは計算時間が増加→致命的</li>
      <li><strong>選択肢C:</strong> 説明結果の解釈には専門知識が必要→本質的誤り</li>
                </ul>
            </div>
        </div>
    </details>
</div>
            
            <footer class="footer">
                <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin: 20px 0;">
                    <p style="margin: 0 0 10px 0; font-size: 0.9rem; color: #6c757d;">
                        <strong>作成者: fuhito.f</strong> | ライセンス: <a href="https://creativecommons.org/licenses/by/4.0/" target="_blank" rel="noopener" style="color: #007bff; text-decoration: underline;">CC-BY 4.0</a>
                    </p>
                    <p style="margin: 0 0 8px 0; font-size: 0.85rem; color: #6c757d;">
                        <strong>共有時はクレジット</strong>: "G検定問題生成AI by fuhito.f" を明記
                    </p>
                    
                </div>
                
                <div style="background: #fff3cd; padding: 15px; border-radius: 6px; border-left: 4px solid #ffc107; margin: 15px 0;">
                    <p style="margin: 0 0 8px 0; font-size: 0.85rem; color: #856404;">
                        本問題は完全オリジナルのAI生成コンテンツです（個人作成）
                    </p>
                    <p style="margin: 0; font-size: 0.85rem; color: #856404;">
                        G検定シラバス2024 v1.3 (G2024#6) の学習分野を参考にしていますが、<br>
                        問題文・解説はすべて独自に作成したものです。<br>
                        <strong>日本ディープラーニング協会（JDLA）の公式教材ではありません。</strong>
                    </p>
                </div>
                
                <div style="background: #ffeaa7; padding: 15px; border-radius: 6px; border-left: 4px solid #f39c12; margin: 15px 0;">
                    <p style="margin: 0; font-size: 0.9rem; color: #8b6914;">
                        <strong>推奨</strong>: 公式テキスト・公式問題集と併用してください
                    </p>
                </div>
            </footer>
        </div>
    </main>
    
    <!-- 印刷ボタン -->
    <button class="print-button" onclick="window.print()" aria-label="このページを印刷">🖨️ 印刷</button>
    
    <!-- JavaScript不要: HTMLのdetailsタグで実装 -->
</body>
</html>
